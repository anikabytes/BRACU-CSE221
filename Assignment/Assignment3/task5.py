# -*- coding: utf-8 -*-
"""task5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10QhCeTxgWvdy1BGFeXkEDHyV21wYAH8h
"""

def apply_BFS(dic, start, goal):
    queue = [[start]]
    
    if start == goal:
        return start 
    source = 0 
    
    while queue :
        before = queue.pop(0)
        source = before[-1]
        if source in dic :
            destin = dic[source]
            for d in destin :
                after =list(before)
                after.append(d)
                queue.append(after)

    return after 

def print_shortest_path(lis,d) :
    ans = ''
    count = 0 
    if type(lis) != int :
        # lis.append(d)
        for i in lis :
            ans += str(i) + ' '
        count = len(lis) - 1 
    else :
        ans = str(lis)
    w.write(f'Time: {count} \nShortest path: {ans}')
  

f = open('/content/input5_1.txt','r')
w = open('/content/output5_1.txt','w')
f1 = f.readline().split()
v = int(f1[0])
c = int(f1[1])
d = int(f1[2].strip())
dic = {}
for i in range(1,v+1) :
    if i not in dic :
        dic[i] = []

for j in range(0,c) :
    rd = f.readline().split()
    source,destin = int(rd[0]),int(rd[1])
    if (source in dic) and (destin not in dic[source]) :
        dic[source].append(destin)

for i,k in enumerate(dic.keys()) :
    if i == 0 :
       a = apply_BFS(dic,k,d)
print_shortest_path(a,d)
w.close()