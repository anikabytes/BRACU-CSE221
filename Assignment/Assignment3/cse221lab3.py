# -*- coding: utf-8 -*-
"""CSE221Lab3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Yop9iHtejVHAF_9xKfy7WjVJP_I_VhmL
"""

# CSE221 Lab 03 Graphs

def readFile():
    # reading file from as input
    # change the file name according to yours
    f = open("/content/graph.txt", "r")
    
    # first line of input contains the number of vertices in the graph
    n = f.readline()
    # strip() gets rid of the new line
    # try printing n without strip()
    print(n.strip())
    n = n.strip()
    print(type(n))
    # n is of type string. we need to convert it to int
    n=int(n)
    print(type(n))
    
    # the second line of the file contains the number of connections
    c = f.readline()
    c = c.strip()
    c = int(c)
    print(c)
    
    # buildGraphUsingDictionary(c,f)
    
    buildGraphUsingListofLists(c,f)



# we want to build an adjacency list like the following
# A -> B,C 
# One vertex can be connected to multiple vertices
# which means multiple values are associated with one vertex
# one data structure that can be used is a dictionary of lists
# {A:[B,C]}

def buildGraphUsingDictionary(c,f): 
    # creating a dictionary
    graph = {}
    # the following lines of the file contain the connections
    # creating a directed graph (a,b means a is connected to b)
    
    counter = 0
    while (counter<c):
        line = f.readline() # reading each libe
        a,b = line.split(",") # splitting the vertices
        b = b.strip() # getting rid of \n from the end
        
        # we first search if the value inside variable a exists in the dictionary or not
        if(a in graph):
            # if yes, then append() the value in b to a
            graph[a].append(b)
        else:
            # create a new list in graph with a as the key and b as the value
            graph[a] = [b]
        # print(a)
        # print(b)
        counter+=1    
    
    print(graph)
    printGraph(graph, None)
       
    
# # TO DO
# # This method must be completed by you
# # You should code in such a way that the output should be
#  # 1 -> 2,4
#  # 2 -> 4
#  # 3 -> 1,4
#  # 4 -> 2
# # notice this method takes both the graphs as parameters
# # this means you have print the same output in the same style for both the datastructures
# # if graph is none then print from listGraph
# # if listGraph is none then print from graph
def printGraph(graph,listGraph):  
    # Your code
    if listGraph == None :
        for k,v in graph.items() :
            print(f'{k} -> {v}')
    else :
        for i in range(0,len(listGraph)) :
            print(f'{listGraph[i][0]} -> {listGraph[i][-1]}')
        

    



# TO DO
# I have shown you how to build a graph using a dictionary of list
# now your job is to build a graph using list of lists [[E,B],[C,D]]
# it means A -> E,B and B -> C,D
def buildGraphUsingListofLists(c,f):
    listGraph = [] # do not change the name of the variable
    
    # your code

    count = 0 
    lis = []
    lis_1 = []
    lis_2=[]

    for i in range(0,c) :
        a,b = f.readline().split(',')
        b = b.strip()
        a,b = int(a),int(b)
        if [a] not in lis :
            lis.append([a])
            lis_1.append([])
        lis_2.append([a,b])
    for j in range(0,len(lis_1)) :
        for k in range(0,len(lis)) :
            if j == k :
                listGraph.append(lis[k])
                listGraph[k].append(lis_1[j])
    
    for p in range(0,len(lis_2)) :
        for m in range(0,len(listGraph)) :
            if lis_2[p][0] == listGraph[m][0] :
                listGraph[m][1].append(lis_2[p][1])
    
    ans = []
    check = 0 
    for i in range(0,len(listGraph)) :
        for j in range(0,len(listGraph)-i-1):
            if listGraph[j][0] > listGraph[j+1][0] :
                listGraph[j][0],listGraph[j+1][0] = listGraph[j+1][0],listGraph[j][0]
                listGraph[j][-1],listGraph[j+1][-1] = listGraph[j+1][-1],listGraph[j][-1]
                count += 1 
        if count == 0 :
            break 
        ans.append(listGraph[i][-1])

    

    print(listGraph)
    print(ans)
    printGraph(None,listGraph)
   
# ======================Program starts here.========================

# read file using the readFile() method
readFile()

def adjacency_matrix(vertex,destin,fil) : 
    import numpy as np
    arr = np.zeros((destin,destin))

    for i in range(0,destin) :
        a,b = fil.readline().strip().split(',')
        arr[int(a),int(b)] = 1.
    return arr 

def adjacency_list(vertex,destin,fil) :
    dic = {}
    for i in range(0,destin) :
        a,b = fil.readline().strip().split(',')
        if int(a) not in dic :
            dic[int(a)] = [int(b)]
        else :
            dic[int(a)].append(int(b))
    
    final = []
    for k,v in dic.items() :
        lis = [k]
        lis.append(v)
        final.append(lis)
    return sorted(final)





f = open('/content/graph.txt','r')
f_copy = open('/content/graph.txt','r')
f_w = open('/content/out.txt','w')
n = int(f.readline().strip())
c = int(f.readline().strip())
n1 = int(f_copy.readline().strip())
c1 = int(f_copy.readline().strip())
f_w.write(f'Ajacency Matrix: \n{adjacency_matrix(n,c,f)} \n====================\n')
f_w.write(f'Adjacency List: \n{adjacency_list(n1,c1,f_copy)}')
f_w.close()