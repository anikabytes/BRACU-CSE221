# -*- coding: utf-8 -*-
"""task4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14_9DrjbFpUgtWDTlahYIYTaie-3wEh5o
"""

# method-1 with bubble sort 
l = []
def check(s) :
    if s != 'see doctor' :
       enque(s)
       
    if s == 'see doctor' : 
        see = seeDoc()  
        return see 

def enque(name) :
    l.append(name.split())
    b = bubblesort(l)
  
def bubblesort(l) :
    for i in range(0,len(l)) :
        for j in range(0,len(l)-i-1):
            if int(l[j][-1]) > int(l[j+1][-1]) :
                l[j][-1],l[j+1][-1] = l[j+1][-1],l[j][-1]
                l[j][0],l[j+1][0] = l[j+1][0],l[j][0]

store = 0 
def seeDoc() :
    global store 
    store += 1 
    return l[store:]     
        
def printQueue(l) :
    for i in range(0,len(l)) :
        f2.write(l[i][0]+'\n')

        

f = open('input4.txt','r')
f2 = open('output4.txt','w')
f1 = f.readlines()

for i in f1 :
    i = i.strip()
    c1 = check(i)
f2.write('Patients remaining (using bubble sort) : '+'\n')
printQueue(c1)

# method-2 with heap sort 
l = []
def check2(s) :
    if s != 'see doctor' :
       enque(s)
       
    if s == 'see doctor' : 
        see = seeDoc()  
        return see 
l = []
def enque(name) :
    global l 
    l.append(name.split())
    h = heapsort(l,len(l)-1)

def heapsort(l,idx) : 
    if idx < 1 :
        return 
    else :
        p = idx//2 
        if int(l[p][-1]) < int(l[idx][-1])  :
            return 
        else :
            l[p][-1],l[idx][-1] = l[idx][-1],l[p][-1]
            l[p][0],l[idx][0] = l[idx][0],l[p][0]
            heapsort(l,p) 


store = 0 
def seeDoc() :
    global store 
    store -= 1
    heapify(l,0)
    return l[-1:-1-store:-1]

def heapify(lis,idx) :

    idx = int(idx)
    parent = idx
    left = (2*idx)+1
    right = (2*idx)+2

    store = 0 
    minim = min(lis[left][-1],lis[right][-1])
    for i in range(0,len(lis)) :
        if minim == lis[i][-1] :
            store = i 
    if (lis[parent][-1] == minim) :
        lis[parent][-1],lis[store][-1],lis[parent][0],lis[store][0] = lis[store][-1],lis[parent][-1],lis[store][0],lis[parent][0]
        heapify(lis,store)
    else :
        return 

def printQueue(l) :
    for i in range(0,len(l)) :
        f3.write(l[i][0]+'\n')   
     


f = open('input4.txt','r')
f3 = open('output4.txt','w')
f1 = f.readlines()
for i in f1 :
    i = i.strip()
    c2 = check2(i)
f3.write('\n'+'Patients remaining (using heap sort) : '+'\n')
printQueue(c2)

# The sequence of patients' names remaining changed when seeDoc() function is called .
printQueue(c1) 
print('===========')
printQueue(c2)

# Comparison 
import time
import math
import matplotlib.pyplot as plt
import numpy as np
#change the value of n for your own experimentation

def bubblesort(l) :
    for i in range(0,len(l)) :
        for j in range(0,len(l)-i-1):
            if l[j] > l[j+1] :
                l[j],l[j+1] = l[j+1],l[j]

def heapsort(l) : 
    idx = len(l)-1
    if idx < 1 :
        return 
    else :
        p = idx//2 
        if l[p] < l[idx]  :
            return 
        else :
            l[p],l[idx] = l[idx],l[p]
            heapsort(l) 



n = len(l)
x = [i for i in range(n)] 
y = [0 for i in range(n)] 
z = [0 for i in range(n)] 

for i in range(n-1):
    start = time.time() 
    bubblesort(x[i+1:]) 
    y[i+1]= time.time()-start 
    start = time.time() 
    heapsort(x[i+1:]) 
    z[i+1]= time.time()-start 
 
x_interval = math.ceil(n/10) 
plt.plot(x, y, 'r') 
plt.plot(x, z, 'b') 
plt.xticks(np.arange(min(x), max(x)+1, x_interval)) 
plt.xlabel('n-th position') 
plt.ylabel('time') 
plt.title('Comparing Time Complexity!') 
plt.legend(['bubble sort', 'heap sort'], loc='best')
plt.show()